<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sketch.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sketch.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*******************************************************************************
 *
 *	@file sketch.js Generate a random walk within a grid based on the work of
 *                  Dan from the coding train
 *
 *	@author Omar Essilfie-Quaye &lt;omareq08@gmail.com>
 *	@version 1.0
 *	@date 11-June-2021
 *  @link https://omareq.github.io/random-walk/
 *
 *****************************************************************************/

/**
 * Monitors how often the reset button is pushed.  This helps provide debouncing
 * of the reset button when it is used on mobile devices.
 *
 * @type       {Float}
 */
let lastResetTime = 0;

/**
 * The number of lattice nodes on the vertical axis of the grid.
 *
 * @type       {Integer}
 */
let verticalGridPoints = 10;

/**
 * Handler for the number of grid points slider.
 *
 * @type       {p5.element}
 */
let verticalGridPointsSlider = undefined;

/**
 * Handler for the paragraphs that displays the current grid size.
 *
 * @type       {p5.element}
 */
let verticalGridPointsDisplay = undefined;

/**
 * The pixel spacing between lattice nodes on the canvas.
 *
 * @type       {Integer}
 */
let spacing = undefined;

/**
 * The generated lattice nodes
 *
 * @type       {Array&lt;GraphNodes>}
 */
let nodes = [];

/**
 * The generated random self avoiding walk
 *
 * @type       {Array&lt;GraohNode>}
 */
let walk = [];

/**
 * Handler for the reset button
 *
 * @type       {p5.element}
 */
let resetButton = undefined;

/**
 * Checks to see if a GraphNode list contains a given node.
 *
 * @param      {Array&lt;GraphNode>}  nodesList     The list of nodes
 * @param      {Array&lt;Integer>}  nodeIndecies  The lattice indecies.  Should not
 *                               have more than 2 elements representing the
 *                               components for each lattice vector.
 * @return     {boolean}  Boolean true if the node is in the list.
 */
function contains(nodesList, nodeIndecies) {
    for(let nodeIndex = 0; nodeIndex &lt; nodesList.length; nodeIndex++) {
        const node = nodesList[nodeIndex];
        if(node.i == nodeIndecies[0] &amp;&amp; node.j == nodeIndecies[1]) {
            return true;
        }
    }
    return false;
}

/**
 * Gets the node specified by the lattice indecies from the list.
 *
 * @param      {Array&lt;GraphNode>}  nodesList     The list of nodes
 * @param      {Array&lt;Integer>}  nodeIndecies  The lattice indecies.  Should not
 *                               have more than 2 elements representing the
 *                               components for each lattice vector.
 * @return     {GraphNode}  The node from list.
 */
function getNodeFromList(nodesList, nodeIndecies) {
    for(let nodeIndex = 0; nodeIndex &lt; nodesList.length; nodeIndex++) {
        const node = nodesList[nodeIndex];
        if(node.i == nodeIndecies[0] &amp;&amp; node.j == nodeIndecies[1]) {
            return node;
        }
    }
}

/**
 * Generate a graph of nodes arranged in a triangular pattern
 */
function generateTriangleGrid() {
    const r1 = createVector(spacing * sqrt(3) / 2, -spacing / 2);
    const r2 = createVector(spacing * sqrt(3) / 2 , spacing / 2);
    console.log("R1: " + r1.x + " " + r1.y);
    console.log("R2: " + r2.x + " " + r2.y);

    for(let i = -25; i &lt; 25; i++) {
        for(let j = 0; j &lt; 60; j++) {
            let pnt = r1.copy().mult(i).add(r2.copy().mult(j));
            pnt.x = pnt.x + 0.5 * spacing;
            pnt.y = pnt.y + 0.5 * spacing;
            if(pnt.x &lt;= 0.5 || pnt.y &lt;= 0.5 || pnt.x >= width-0.5 || pnt.y >= height-0.5) {
                continue;
            }
            nodes.push(new GraphNode(i, j, pnt.x, pnt.y));
        }
    }

    for(let nodeIndex = 0; nodeIndex &lt; nodes.length; nodeIndex++) {
        const currentNode = nodes[nodeIndex];
        const i = currentNode.i;
        const j = currentNode.j;
        const possibleNeighbors = [
            [i, j + 1],
            [i, j - 1],
            [i + 1, j],
            [i - 1, j]
        ];

        for(let n = possibleNeighbors.length - 2; n >= 0; n--) {
            if(!contains(nodes, possibleNeighbors[n])) {
                possibleNeighbors.splice(1, n);
            }
        }
        nodes[nodeIndex].setNeighbours(possibleNeighbors);
    }
}


/**
 * Generates a random walk given a list of nodes in a grid
 */
function generateWalk() {
    randomNodeIndex = floor(random(nodes.length));
    let currentNode = nodes[randomNodeIndex];
    currentNode.visited = true;
    walk = [];
    walk.push(currentNode);
    let watchdog = nodes.length;
    console.log("watchdog: " + watchdog);
    while(watchdog > 0) {
        watchdog--;

        orderedNeighbours = currentNode.neighbours;
        neighbours = shuffle(orderedNeighbours);
        let foundUnvisitedNeighbour = false;

        for(let n = 0; n &lt; neighbours.length; n++) {
            if(!contains(nodes, neighbours[n])) {
                continue;
            }
            currentNeighbour = getNodeFromList(nodes, neighbours[n]);
            if(!currentNeighbour.visited) {
                currentNode = currentNeighbour;
                currentNode.visited = true;
                foundUnvisitedNeighbour = true;
                walk.push(currentNode);
                break;
            }
        }

        if(!foundUnvisitedNeighbour) {
            console.log("No more unvisited neighbours");
            console.log("watchdog: " + watchdog);
            break;
        }
    }
}

/**
 * Resets the canvas and draws a new random walk.
 */
function reset() {
    if(millis() - lastResetTime &lt; 275) {
        return;
    }

    for(let nodeIndex = 0; nodeIndex &lt; nodes.length; nodeIndex++) {
        let currentNode = nodes[nodeIndex];
        currentNode.visited = false;
    }
    spacing = height / verticalGridPoints;
    walk = [];
    nodes = [];
    generateTriangleGrid();
    generateWalk();

    lastResetTime = millis();
}

/**
 * p5.js setup function, creates canvas.
 */
function setup() {
	let cnvSize;
	if(windowWidth > windowHeight) {
		cnvSize = windowHeight;
	} else {
		cnvSize = windowWidth;
	}
	let cnv = createCanvas(cnvSize, 0.7 * cnvSize);
	cnv.parent('sketch');

    spacing = height / verticalGridPoints;
    generateTriangleGrid();
    generateWalk();
    console.log("Generated Walk:");
    console.log(walk);

    verticalGridPointsDisplay = createP("Number of Vertical Grid Points: " +
        str(verticalGridPoints));
    verticalGridPointsDisplay.parent("vertical-grid-points-val");

    verticalGridPointsSlider = createSlider(4, 25, verticalGridPoints, 1);
    verticalGridPointsSlider.parent("vertical-grid-points");

    resetButton = createButton("Reset", "value");
    resetButton.parent("reset-button");
    resetButton.mousePressed(reset);
}

/**
 * p5.js draw function, is run every frame to create the desired animation
 */
function draw() {
	background(0);
    stroke(255);
    fill(255);
    for(let i = 0; i &lt; nodes.length; i++) {
        ellipse(nodes[i].x, nodes[i].y, spacing / 8, spacing / 8);
    }

    fill(255, 0, 0);
    stroke(255, 0, 0);
    ellipse(walk[0].x, walk[0].y, spacing / 8, spacing / 8);
    for(let i = 1; i &lt; walk.length; i++) {
        noStroke();
        ellipse(walk[i].x, walk[i].y, spacing / 8, spacing / 8);
        stroke(0, 255, 0);
        strokeWeight(2);
        line(walk[i].x, walk[i].y, walk[i-1].x, walk[i-1].y);
    }
        stroke(0, 0, 255);
        fill(0, 0, 255);
        ellipse(walk[walk.length - 1].x, walk[walk.length - 1].y,
            spacing / 8, spacing / 8);

    let sliderVal = verticalGridPointsSlider.value();
    if(sliderVal != verticalGridPoints) {
        verticalGridPoints = sliderVal;
        verticalGridPointsDisplay.elt.innerText = "Number of Vertical Grid Points: " +
            str(verticalGridPoints);
        reset();
    }
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GraphNode.html">GraphNode</a></li></ul><h3>Global</h3><ul><li><a href="global.html#contains">contains</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#generateTriangleGrid">generateTriangleGrid</a></li><li><a href="global.html#generateWalk">generateWalk</a></li><li><a href="global.html#getNodeFromList">getNodeFromList</a></li><li><a href="global.html#lastResetTime">lastResetTime</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetButton">resetButton</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#spacing">spacing</a></li><li><a href="global.html#verticalGridPoints">verticalGridPoints</a></li><li><a href="global.html#verticalGridPointsDisplay">verticalGridPointsDisplay</a></li><li><a href="global.html#verticalGridPointsSlider">verticalGridPointsSlider</a></li><li><a href="global.html#walk">walk</a></li></ul>
</nav>

<br class="clear">

Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Mar 23 2022 17:04:51 GMT+0000 (GMT)
<footer>
    <div class="links">
        <a href="https://github.com/omareq/" class="github-profile"><span>Github Profile</span></a>
        <a href="../../" class="githubio"><span>Github.io Home</span></a>
        <a href="http://iamoquaye.ga/" class="iamoquaye"><span>iamoquaye</span></a>
    </div>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
